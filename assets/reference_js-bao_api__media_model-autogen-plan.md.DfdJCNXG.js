import{_ as s,c as i,o as a,aj as t}from"./chunks/framework.HLg5PcC2.js";const g=JSON.parse('{"title":"Model File Auto-Generation Plan","description":"","frontmatter":{},"headers":[],"relativePath":"reference/js-bao/api/_media/model-autogen-plan.md","filePath":"reference/js-bao/api/_media/model-autogen-plan.md"}'),l={name:"reference/js-bao/api/_media/model-autogen-plan.md"};function o(n,e,r,d,h,c){return a(),i("div",null,[...e[0]||(e[0]=[t(`<h1 id="model-file-auto-generation-plan" tabindex="-1">Model File Auto-Generation Plan <a class="header-anchor" href="#model-file-auto-generation-plan" aria-label="Permalink to â€œModel File Auto-Generation Planâ€">â€‹</a></h1><h2 id="goals" tabindex="-1">Goals <a class="header-anchor" href="#goals" aria-label="Permalink to â€œGoalsâ€">â€‹</a></h2><ul><li>Provide a consistent schema-first model layout without decorators or <code>createModelClass</code>.</li><li>Keep schema objects and business logic fully developer-editable.</li><li>Let <code>js-bao-codegen</code> own the repetitive glue (types, lint comments, registration wiring).</li><li>Introduce a single helper (<code>attachAndRegisterModel</code>) for the common case, while preserving granular helpers for advanced flows (e.g., Scenario 16).</li></ul><h2 id="template-structure" tabindex="-1">Template Structure <a class="header-anchor" href="#template-structure" aria-label="Permalink to â€œTemplate Structureâ€">â€‹</a></h2><p>Each model file will contain three regions:</p><ol><li><p><strong>User Header</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { BaseModel, defineModelSchema } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;js-bao&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> someSchema</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineModelSchema</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div><p>Developers edit schema fields, relationships, defaults, etc., directly in this section.</p></li><li><p><strong>ðŸ”¥ðŸ”¥ BEGIN/END AUTO HEADER ðŸ”¥ðŸ”¥</strong> (generator-owned)<br> Contents:</p><ul><li>Lint suppression (<code>/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */</code>).</li><li>Imports for <code>InferAttrs</code>, <code>attachAndRegisterModel</code>.</li><li><code>export type FooAttrs = InferAttrs&lt;typeof fooSchema&gt;;</code></li><li><code>export interface Foo extends FooAttrs, BaseModel {}</code></li><li>(If needed) minimal empty <code>export class Foo extends BaseModel {}</code> stub when no class exists yet. On subsequent runs, the generator leaves any user-authored class outside the auto block untouched.</li></ul></li><li><p><strong>User Class Body</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BaseModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(...) { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  async</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> helper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Developers own the entire class definition and can use <code>this</code>/<code>super</code> normally.</p></li><li><p><strong>ðŸ”¥ðŸ”¥ BEGIN/END AUTO FOOTER ðŸ”¥ðŸ”¥</strong> (generator-owned)<br> Contents:</p><ul><li><code>import &quot;./generated/Foo.relationships.d&quot;;</code></li><li><code>attachAndRegisterModel(Foo, fooSchema);</code></li><li>Future boilerplate (e.g., logging hooks) can be added here without touching user code.</li></ul></li></ol><h2 id="helper-strategy" tabindex="-1">Helper Strategy <a class="header-anchor" href="#helper-strategy" aria-label="Permalink to â€œHelper Strategyâ€">â€‹</a></h2><ul><li><strong>New helper</strong>: <code>attachAndRegisterModel(modelClass, schema)</code> which internally sets static metadata, calls <code>attachSchemaToClass</code>, and registers the class with the default <code>ModelRegistry</code>.</li><li><strong>Existing helpers stay exported</strong>: <code>attachSchemaToClass</code> and <code>autoRegisterModel</code>. Scenario 16 (dynamic runtime registration) can call them separately when it needs to register with a custom registry or delay registration.</li><li><strong>Documentation update</strong>: README + migration guide will show the new helper and clarify when to use the granular helpers.</li></ul><h2 id="codegen-responsibilities" tabindex="-1">Codegen Responsibilities <a class="header-anchor" href="#codegen-responsibilities" aria-label="Permalink to â€œCodegen Responsibilitiesâ€">â€‹</a></h2><ol><li>Detect existing firecracker markers; rewrite only the auto blocks.</li><li>When first creating a file: <ul><li>Emit schema placeholder (if not already provided) or assume the developer added it.</li><li>Insert the auto header/footer.</li><li>Add an empty <code>export class Foo extends BaseModel {}</code> stub in the user region if no class exists.</li></ul></li><li>On subsequent runs: <ul><li>Preserve all user-authored code outside the auto blocks.</li><li>Update imports, lint comments, relationship paths, and helper calls inside the blocks as needed.</li></ul></li><li>Warn (or back up) if the markers are missing or tampered with.</li></ol><h2 id="programmatic-models-scenario-16" tabindex="-1">Programmatic Models (Scenario 16) <a class="header-anchor" href="#programmatic-models-scenario-16" aria-label="Permalink to â€œProgrammatic Models (Scenario 16)â€">â€‹</a></h2><ul><li>Runtime-defined classes will: <ol><li>Call <code>defineModelSchema</code> at runtime.</li><li>Declare a <code>class RuntimeItem extends BaseModel { ... }</code>.</li><li>Call either <code>attachAndRegisterModel(RuntimeItem, runtimeItemSchema)</code> or, for custom behavior, <code>attachSchemaToClass(RuntimeItem, runtimeItemSchema)</code> followed by manual <code>ModelRegistry.registerModel(...)</code>.</li></ol></li><li>No decorators or <code>createModelClass</code> are required; the same helpers ensure the runtime class has <code>modelName</code>, <code>schema</code>, and registry entries.</li></ul><h2 id="deprecating-createmodelclass" tabindex="-1">Deprecating <code>createModelClass</code> <a class="header-anchor" href="#deprecating-createmodelclass" aria-label="Permalink to â€œDeprecating createModelClassâ€">â€‹</a></h2><ul><li>Update docs and codegen output so new models never reference <code>createModelClass</code>.</li><li>Mark the helper as deprecated in the public API (tsdoc + console warning) once all internal usage migrates to the class-based pattern.</li><li>Provide migration guidance that shows how to convert <code>createModelClass</code> files to the new template (schema + class + firecracker auto blocks).</li></ul><h2 id="next-steps" tabindex="-1">Next Steps <a class="header-anchor" href="#next-steps" aria-label="Permalink to â€œNext Stepsâ€">â€‹</a></h2><ol><li>Implement the template + marker updates in <code>js-bao-codegen</code>.</li><li>Export the combined helper and update README/docs.</li><li>Run codegen across the repo to migrate existing model files.</li><li>Deprecate <code>createModelClass</code> and monitor Scenario 16/other runtime flows to confirm they still work with the granular helpers.</li></ol>`,16)])])}const k=s(l,[["render",o]]);export{g as __pageData,k as default};
